================================================================================
FILE: .\config.py
================================================================================

import os
import sys

# =========================
# 基本信息
# =========================

APP_TITLE = "大华法国驻地专用自动化 报价计算|查询|信息汇总 mini软件"
DATA_DATE = "2025.11.24"
AUTHOR_INFO = (
    "当前仍处于测试阶段,若对数据产生疑问请立刻联系对应PM和技术人员进行价格核对\n"
    "对于硬盘存储类设备，近期价格波动频繁，请注意实时报价\n"
    "使用中发现任何问题，请联系开发人员 林建克 LIN Jianke\n"
    "Huachat: Jianke LIN | 微信: Epochex404"
)


# =========================
# 路径工具
# =========================

def get_base_dir() -> str:
    """
    返回程序“根目录”：
    - 源码运行：config.py 所在目录
    - PyInstaller 打包：sys._MEIPASS
    """
    if hasattr(sys, "_MEIPASS"):
        return sys._MEIPASS  # type: ignore[attr-defined]
    return os.path.dirname(os.path.abspath(__file__))


def get_data_path(filename: str) -> str:
    """
    data 目录下文件：
        data/FrancePrice.xlsx
        data/SysPrice.xls
    """
    base_dir = get_base_dir()
    data_dir = os.path.join(base_dir, "data")
    return os.path.join(data_dir, filename)


def get_mapping_path(filename: str) -> str:
    """
    mapping 目录下文件：
        mapping/productline_map_france_full.csv
        mapping/productline_map_sys_full.csv
    """
    base_dir = get_base_dir()
    mapping_dir = os.path.join(base_dir, "mapping")
    return os.path.join(mapping_dir, filename)


def get_file_in_base(filename: str) -> str:
    """
    根目录下文件：
        List_PN.txt
        Country_import_upload_Model.xlsx
        Country&Customer_import_upload_Model.xlsx
    """
    base_dir = get_base_dir()
    return os.path.join(base_dir, filename)


================================================================================
FILE: .\export.py
================================================================================

import os

def export_py_files(root_dir, output_file="code_description.txt"):
    with open(output_file, "w", encoding="utf-8") as out:
        for dirpath, _, filenames in os.walk(root_dir):
            for filename in filenames:
                if filename.endswith(".py"):
                    file_path = os.path.join(dirpath, filename)

                    out.write("=" * 80 + "\n")
                    out.write(f"FILE: {file_path}\n")
                    out.write("=" * 80 + "\n\n")

                    try:
                        with open(file_path, "r", encoding="utf-8") as f:
                            content = f.read()
                    except UnicodeDecodeError:
                        # 回退到 latin-1 防止非 UTF-8 文件直接 crash
                        with open(file_path, "r", encoding="latin-1") as f:
                            content = f.read()

                    out.write(content)
                    out.write("\n\n")

    print(f"Done. All .py files exported to {output_file}")


if __name__ == "__main__":
    # 修改为你要扫描的目录，例如当前目录 "."
    export_py_files(".")


================================================================================
FILE: .\main.py
================================================================================

import sys
from typing import List, Dict

import os
import pandas as pd

from config import (
    APP_TITLE,
    DATA_DATE,
    AUTHOR_INFO,
    get_file_in_base,
)
from core.loader import (
    load_france_price,
    load_sys_price,
    load_france_mapping,
    load_sys_mapping,
)
from core.pricing_engine import compute_prices_for_part
from core.formatter import render_table, build_status_line


# =========================
# PN 标准化工具
# =========================

def normalize_pn_raw(raw) -> str:
    """
    原样标准化：
    - 转字符串
    - strip 去空格
    - lower 小写
    不做任何截断，用于“完全匹配”。
    """
    if raw is None:
        return ""
    return str(raw).strip().lower()


def normalize_pn_base(raw) -> str:
    """
    “前缀 key” 标准化，用于兜底匹配。

    需求：1.0.01.01.16317-9002 == 1.0.01.01.16317

    规则：
    1) 先做 normalize_pn_raw 得到 s
    2) 若 s 中包含 '-'，拆成 base-suffix：
       - 如果 base 只由 [0-9 .] 组成，且包含至少一个 '.'，
         认为是 Dahua 内部编码：返回 base 作为前缀 key
       - 否则不截断，直接返回 s
    3) 没有 '-' 就直接返回 s
    """
    s = normalize_pn_raw(raw)
    if not s:
        return ""

    base, sep, suffix = s.partition("-")
    if sep and base and suffix:
        base_compact = base.replace(" ", "")
        # 限定：只在“点分数字”风格编码上去掉后缀，避免误伤其他真带“-”的料号
        if base_compact and all((c.isdigit() or c == ".") for c in base_compact) and "." in base_compact:
            return base

    return s


def _prepare_index(df: pd.DataFrame, col_name: str) -> pd.DataFrame:
    """
    给 DataFrame 增加两个 key：
    - _pn_key_raw  : 用于完全匹配
    - _pn_key_base : 用于前缀兜底匹配
    """
    df = df.copy()
    df["_pn_key_raw"] = df[col_name].apply(normalize_pn_raw)
    df["_pn_key_base"] = df[col_name].apply(normalize_pn_base)
    return df


# =========================
# 匹配工具
# =========================

def _mode_label(mode: str) -> str:
    """
    把内部匹配模式翻译成可读中文。
    """
    if mode == "exact_raw":
        return "精确匹配"
    if mode == "fallback_suffix_to_base":
        return "输入带后缀，回退到无后缀基础料号"
    if mode == "fallback_base_to_suffix":
        return "输入无后缀，回退到带后缀国际料号"
    return "未匹配"


def _find_row_with_fallback(
    df: pd.DataFrame,
    key_raw: str,
    key_base: str,
    pn_col_name: str,
):
    """
    在 df 中按“精确 → 兜底”的顺序找一行，且区分输入是否带后缀。

    返回 (row_or_None, match_mode, matched_pn_str)

    情况 1：输入不带后缀，例如 1.0.01.19.10564
      1) 先按 _pn_key_raw == key_raw 精确匹配
      2) 若找不到，再按 _pn_key_base == key_base 匹配
         （可以匹配到 1.0.01.19.10564-9001 这类带国际后缀的行）

    情况 2：输入带后缀，例如 1.0.01.19.10564-9001
      1) 先按 _pn_key_raw == key_raw 精确匹配
      2) 若找不到，再按 _pn_key_raw == key_base 匹配
         （即只兜底到“不带后缀”的基础料号 1.0.01.19.10564）
    """
    if not key_raw and not key_base:
        return None, "none", None

    # 先尝试精确匹配
    if key_raw:
        m = df[df["_pn_key_raw"] == key_raw]
        if not m.empty:
            row = m.iloc[0]
            matched_pn = row.get(pn_col_name)
            return row, "exact_raw", matched_pn

    if not key_base:
        return None, "none", None

    # 判断“输入是否带有可截断的后缀”
    has_suffix = ("-" in key_raw) and (key_base != key_raw)

    if has_suffix:
        # 输入带后缀：兜底只找“没有后缀”的那一行（raw == base）
        m = df[df["_pn_key_raw"] == key_base]
        if not m.empty:
            row = m.iloc[0]
            matched_pn = row.get(pn_col_name)
            return row, "fallback_suffix_to_base", matched_pn
    else:
        # 输入不带后缀：兜底找任意 base 相同的行（可以是带后缀的国际料号）
        m = df[df["_pn_key_base"] == key_base]
        if not m.empty:
            row = m.iloc[0]
            matched_pn = row.get(pn_col_name)
            return row, "fallback_base_to_suffix", matched_pn

    return None, "none", None


# =========================
# 导出 DataFrame 构造
# =========================

def build_export_df(rows: List[Dict], level: str) -> pd.DataFrame:
    """
    rows: 每个元素是 compute_prices_for_part 的 result["final_values"]。
    level: "1" -> Country; "2" -> Country&Customer
    """
    data = []

    for fv in rows:
        pn = fv.get("Part No.")
        fob = fv.get("FOB C(EUR)")
        ddp = fv.get("DDP A(EUR)")
        reseller = fv.get("Suggested Reseller(EUR)")
        gold = fv.get("Gold(EUR)")
        silver = fv.get("Silver(EUR)")
        ivory = fv.get("Ivory(EUR)")
        msrp = fv.get("MSRP(EUR)")

        if level == "1":
            # Country 模板
            row = {
                "Part No.": pn,
                "FOB C": fob,
                "DDP A": ddp,
                "Reseller S": reseller,
                "SI-S": gold,     # Gold
                "SI-A": silver,   # Silver
                "MSTP": ivory,    # MSTP = Ivory
                "MSRP": msrp,
            }
        else:
            # Country & Customer 模板
            si_a = gold  # Gold
            si_s = si_a  # Diamond = Gold
            row = {
                "Part No.": pn,
                "FOB C": fob,
                "DDP A": ddp,
                "Reseller S": reseller,
                "SI-S": si_s,     # Diamond (同 Gold)
                "SI-A": si_a,     # Gold
                "SI-B": silver,   # Silver
                "MSTP": ivory,     # Ivory
                "MSRP": msrp,
            }

        data.append(row)

    return pd.DataFrame(data)


# =========================
# 批量模式
# =========================

def run_batch(
    france_df: pd.DataFrame,
    sys_df: pd.DataFrame,
    france_map: pd.DataFrame,
    sys_map: pd.DataFrame,
) -> None:
    """
    批量模式：
      - 读取根目录 List_PN.txt，每行一个 PN
      - 对每个 PN 计算价格
      - 在控制台打印每个 PN 的表格结果（含 Original/Calculated 标记）
      - 导出 Country / Country&Customer 模板
      - 所有 PN 处理完后，再一次性汇总输出“找不到的 PN 列表”
    """
    list_path = get_file_in_base("List_PN.txt")
    if not os.path.exists(list_path):
        print(f"❌ 未找到批量 PN 列表文件：{list_path}")
        return

    with open(list_path, "r", encoding="utf-8") as f:
        pns = [line.strip() for line in f if line.strip()]

    if not pns:
        print("❌ List_PN.txt 为空，批量处理取消。")
        return

    print(f"\n检测到批量模式，共 {len(pns)} 个 PN，将依次计算价格...\n")

    results_for_export: List[Dict] = []
    not_found: List[str] = []

    for idx, pn in enumerate(pns, start=1):
        key_raw = normalize_pn_raw(pn)
        key_base = normalize_pn_base(pn)

        fr_row, fr_mode, fr_matched = _find_row_with_fallback(
            france_df, key_raw, key_base, "Part No."
        )
        sys_row, sys_mode, sys_matched = _find_row_with_fallback(
            sys_df, key_raw, key_base, "Part Num"
        )

        if fr_row is None and sys_row is None:
            # 暂时只记录，等所有 PN 处理完再统一输出
            not_found.append(pn)
            continue

        # ===== 匹配信息提示 =====
        print("=" * 80)
        print(f"[Batch {idx}/{len(pns)}] PN = {pn}")
        print(
            f"[Match] France: {fr_matched if fr_matched is not None else '未命中'} "
            f"({ _mode_label(fr_mode) }) | "
            f"Sys: {sys_matched if sys_matched is not None else '未命中'} "
            f"({ _mode_label(sys_mode) })"
        )

        result = compute_prices_for_part(pn, fr_row, sys_row, france_map, sys_map)

        # 报价维度一律使用“输入的 PN”，而不是底层匹配到的 France/Sys PN
        fv = result["final_values"]
        fv["Part No."] = pn

        print(build_status_line(result))
        print()
        print(render_table(fv, result["calculated_fields"]))
        print()

        # 简单检查：至少有 DDP A，否则基本没法上传
        if fv.get("DDP A(EUR)") is None:
            print(f"[Warn] PN={pn} 未得到有效 DDP A 价格，仍写入导出表但需人工复核。")

        results_for_export.append(fv)

    # 先输出“完全找不到”的 PN 汇总信息
    if not_found:
        print("\n以下 PN 在 France / Sys 中均未找到（已跳过）：")
        for pn in not_found:
            print(f"[Skip] PN={pn} 在 France / Sys 中均未找到，跳过。")

    if not results_for_export:
        print("\n❌ 没有任何 PN 计算成功，批量处理结束。")
        return

    # 选择导出模板层级
    print("\n价格处理完成，即将导出为上传模板，定价层级为？")
    print("  Country 层级输入 1")
    print("  Country & Customer 层级输入 2")

    level = input("请输入 1 / 2（输入 q 放弃导出）：").strip()
    while level not in {"1", "2"}:
        if level.lower() in {"q", "quit", "exit"}:
            print("已放弃导出。")
            return
        level = input("请输入 1 或 2（输入 q 放弃导出）：").strip()

    df_export = build_export_df(results_for_export, level)

    if level == "1":
        out_name = "Country_import_upload_Model.xlsx"
    else:
        out_name = "Country&Customer_import_upload_Model.xlsx"

    out_path = get_file_in_base(out_name)
    df_export.to_excel(out_path, index=False)
    print(f"\n✅ 导出完成：{out_path}\n")


# =========================
# 交互主循环
# =========================

def main() -> None:
    print("=" * 80)
    print(APP_TITLE)
    print(f"当前价格数据源更新日期：{DATA_DATE}")
    print(AUTHOR_INFO)
    print("=" * 80)

    # ===== 载入数据 =====
    try:
        france_df = load_france_price()
    except FileNotFoundError:
        print("❌ 无法找到 data/FrancePrice.xlsx，请检查 data 目录。")
        input("按回车退出...")
        sys.exit(1)

    try:
        sys_df = load_sys_price()
    except FileNotFoundError:
        print("❌ 无法找到 data/SysPrice.xls，请检查 data 目录。")
        input("按回车退出...")
        sys.exit(1)

    france_map = load_france_mapping()
    sys_map = load_sys_mapping()

    # 标准化 PN 索引：同时生成 raw/base 两套 key
    france_df = _prepare_index(france_df, "Part No.")
    sys_df = _prepare_index(sys_df, "Part Num")

    while True:
        part_no = input("\n请输入 Part No.（输入 quit 退出，直接回车进入批量模式）：").strip()

        # 批量模式
        if part_no == "":
            run_batch(france_df, sys_df, france_map, sys_map)
            continue

        if part_no.lower() in {"quit", "exit", "q"}:
            print("程序已退出，Merci Auvoir！")
            break

        key_raw = normalize_pn_raw(part_no)
        key_base = normalize_pn_base(part_no)

        fr_row, fr_mode, fr_matched = _find_row_with_fallback(
            france_df, key_raw, key_base, "Part No."
        )
        sys_row, sys_mode, sys_matched = _find_row_with_fallback(
            sys_df, key_raw, key_base, "Part Num"
        )

        if fr_row is None and sys_row is None:
            print("❌ France / Sys 中均未找到该 PN，请确认 PN 是否正确或联系 PM 新增。")
            continue

        print(
            f"[Match] France: {fr_matched if fr_matched is not None else '未命中'} "
            f"({ _mode_label(fr_mode) }) | "
            f"Sys: {sys_matched if sys_matched is not None else '未命中'} "
            f"({ _mode_label(sys_mode) })"
        )

        result = compute_prices_for_part(part_no, fr_row, sys_row, france_map, sys_map)

        # 同样在单条查询里覆盖 Part No. 为“输入的 PN”
        result["final_values"]["Part No."] = part_no

        print("\n查询结果如下：")
        print(build_status_line(result))
        print()
        print(render_table(result["final_values"], result["calculated_fields"]))


if __name__ == "__main__":
    main()


================================================================================
FILE: .\core\classifier.py
================================================================================

import re
from typing import Optional, Tuple

import pandas as pd


def safe_upper(v) -> str:
    if v is None:
        return ""
    try:
        if pd.isna(v):
            return ""
    except Exception:  # noqa: BLE001
        pass
    return str(v).strip().upper()


def _normalize_field_name(f) -> str:
    if not isinstance(f, str):
        return ""
    f = f.strip()
    if not f or f.lower() == "nan":
        return ""
    return f


def apply_mapping(row: pd.Series, mapping: pd.DataFrame) -> Tuple[str, Optional[str]]:
    """
    通用映射逻辑：
      - 逐行按 priority 顺序匹配
      - 支持 equals / contains 两种模式
      - 返回 (category, price_group_hint)
    """
    if mapping is None or mapping.empty:
        return "UNKNOWN", None

    for _, rule in mapping.iterrows():
        field1 = _normalize_field_name(rule.get("field1"))
        if not field1:
            continue
        match_type1 = str(rule.get("match_type1") or "").strip().lower()
        pattern1 = safe_upper(rule.get("pattern1"))
        value1 = safe_upper(row.get(field1))

        if match_type1 == "equals":
            if value1 != pattern1:
                continue
        elif match_type1 == "contains":
            if pattern1 not in value1:
                continue
        else:
            continue

        field2 = _normalize_field_name(rule.get("field2"))
        if field2:
            match_type2 = str(rule.get("match_type2") or "").strip().lower()
            pattern2 = safe_upper(rule.get("pattern2"))
            value2 = safe_upper(row.get(field2))

            if match_type2 == "equals":
                if value2 != pattern2:
                    continue
            elif match_type2 == "contains":
                if pattern2 not in value2:
                    continue
            else:
                continue

        category = str(rule.get("category") or "").strip()
        price_group = str(rule.get("price_group_hint") or "").strip() or None
        if not category:
            continue
        return category, price_group

    return "UNKNOWN", None


# ========= Series 识别（给 PRICE_RULES 用） =========


def _detect_ipc_series_key(big: str) -> str:
    """
    big: 已经 upper() 的串，包含 Series / Internal / External 的拼接
    返回给 PRICE_RULES 用的 series key，比如 "PSDW" / "IPC2" / "IPC3-S2" 等
    """

    # 先看明显的字串
    if "PSDW" in big:
        return "PSDW"
    if "PINHOLE" in big or "针孔" in big:
        return "针孔"

    # Multi-sensor / Special 系
    if "MULTI-SENSOR" in big or "MULTISENSOR" in big or "SPECIAL" in big or "IPC7" in big:
        return "IPC5/7/MULTI-SENSOR / SPECIAL"

    # 直接带 IPC5 / IPC3 / IPC2 / IPC1 文本的
    for key in ["IPC5", "IPC3-S2", "IPC2-PRO", "IPC2", "IPC1"]:
        if key in big:
            return key

    # 根据 HFW/HDW 后第一位数字猜代数
    m = re.search(r"H[DF]W(\d)", big)
    if m:
        d = m.group(1)
        if d == "5":
            return "IPC5"
        if d == "3":
            return "IPC3-S2"
        if d == "2":
            # 再看有没有 PRO
            if "PRO" in big:
                return "IPC2-PRO"
            return "IPC2"
        if d == "1":
            return "IPC1"

    return ""


def detect_series(
    france_row: Optional[pd.Series],
    sys_row: Optional[pd.Series],
    price_group: Optional[str],
) -> Tuple[str, str]:
    """
    返回 (series_display, series_key_for_price_rules)

    series_display: 给用户看的 Series（直接取 France 的 Series / 系列）
    series_key_for_price_rules: 用于在 PRICE_RULES[price_group] 里选择子规则
    """
    # 展示用 Series：优先 France 表
    series_display = ""
    if france_row is not None:
        for col in ("Series", "系列"):
            if col in france_row and pd.notna(france_row[col]):
                series_display = str(france_row[col]).strip()
                break
    if not series_display and sys_row is not None:
        # 兜底：用 Sys 的 Second Product Line
        for col in ("Second Product Line", "Catelog Name"):
            if col in sys_row and pd.notna(sys_row[col]):
                series_display = str(sys_row[col]).strip()
                break

    # 给 PRICE_RULES 用的 series key
    series_key = ""
    pg = (price_group or "").strip().upper()
    if pg == "IPC":
        pieces = []
        if france_row is not None:
            for col in ("Series", "系列", "External Model", "Internal Model"):
                if col in france_row and pd.notna(france_row[col]):
                    pieces.append(str(france_row[col]))
        if sys_row is not None:
            for col in ("Internal Model", "External Model", "Second Product Line"):
                if col in sys_row and pd.notna(sys_row[col]):
                    pieces.append(str(sys_row[col]))
        big = safe_upper(" ".join(pieces))
        series_key = _detect_ipc_series_key(big)

    # Thermal 简单处理
    if pg == "THERMAL":
        if france_row is not None:
            s_up = safe_upper(france_row.get("Series") or france_row.get("系列"))
            if "TPC4" in s_up or "TPC5" in s_up:
                series_key = "TPC4 TPC5"
            elif "TPC" in s_up:
                series_key = "TPC"

    # 其他品类目前用不到细分规则，返回空即可（PRICE_RULES 会走 _default_）
    return series_display, series_key or ""
    

def classify_category_and_price_group(
    france_row: Optional[pd.Series],
    sys_row: Optional[pd.Series],
    france_map: pd.DataFrame,
    sys_map: pd.DataFrame,
) -> Tuple[str, Optional[str]]:
    """
    综合 France + Sys 两侧信息确定 category & price_group_hint。
    优先使用 France 映射，失败再用 Sys，最后兜底 IPC。
    """
    if france_row is not None:
        cat, grp = apply_mapping(france_row, france_map)
        if cat != "UNKNOWN":
            return cat, grp or cat

    if sys_row is not None:
        cat, grp = apply_mapping(sys_row, sys_map)
        if cat != "UNKNOWN":
            return cat, grp or cat

    # 最终兜底：按 IPC 处理
    return "IPC", "IPC"


================================================================================
FILE: .\core\formatter.py
================================================================================

import math
from typing import Dict, Iterable, Set

from tabulate import tabulate


COLUMNS_TO_SHOW = [
    "Part No.",
    "Series",
    "External Model",
    "Internal Model",
    "Sales Status",
    "Description",
    "FOB C(EUR)",
    "DDP A(EUR)",
    "Suggested Reseller(EUR)",
    "Gold(EUR)",
    "Silver(EUR)",
    "Ivory(EUR)",
    "MSRP(EUR)",
]

BOLD_COLS = {
    "Part No.",
    "FOB C(EUR)",
    "DDP A(EUR)",
    "Suggested Reseller(EUR)",
    "Gold(EUR)",
    "Silver(EUR)",
    "Ivory(EUR)",
    "MSRP(EUR)",
}

# 需要打 Original / Calculated 标记的价格列
PRICE_COLS = {
    "FOB C(EUR)",
    "DDP A(EUR)",
    "Suggested Reseller(EUR)",
    "Gold(EUR)",
    "Silver(EUR)",
    "Ivory(EUR)",
    "MSRP(EUR)",
}


def _format_value(v):
    if v is None:
        return "Value Not Found"
    try:
        if isinstance(v, float) and math.isnan(v):
            return "Price Not Found"
    except Exception:  # noqa: BLE001
        pass
    return v


def render_table(
    final_values: Dict[str, object],
    calculated_fields: Iterable[str],
) -> str:
    """
    把结果 dict 渲染成表格。

    规则：
    - 只对“Calculated”的价格做格式处理：
        * 数值 < 10  → 保留 1 位小数
        * 数值 >=10 → 向上取整成整数（无小数）
    - Original 的价格保持原值（不改小数位），只追加标记。
    """
    calc_set: Set[str] = set(calculated_fields)
    rows = []

    seen = set()
    for col in COLUMNS_TO_SHOW:
        if col in seen:
            continue
        seen.add(col)

        raw = final_values.get(col)

        # ===== 只对“Calculated 的价格列”做数值格式 =====
        if col in PRICE_COLS and raw is not None and col in calc_set:
            try:
                num = float(raw)
                if math.isnan(num):
                    raw = None
                else:
                    if num < 10:
                        # <10：保留 1 位小数（正常四舍五入）
                        raw = f"{num:.1f}"
                    else:
                        # >=10：向上取整成整数
                        raw = str(math.ceil(num))
            except (TypeError, ValueError):
                # 不是数值就保持原样
                pass

        val = _format_value(raw)

        # ===== Original / Calculated 标记 =====
        if col in PRICE_COLS and val != "Price Not Found":
            if col in calc_set:
                val = f"{val} | Calculated"
            else:
                val = f"{val} | Original"

        # ===== 加粗关键列 =====
        if col in BOLD_COLS:
            col_disp = f"\033[1m{col}\033[0m"
            val_disp = f"\033[1m{val}\033[0m"
        else:
            col_disp = col
            val_disp = val

        rows.append([col_disp, val_disp])

    return tabulate(rows, headers=["Name", "Value"], tablefmt="grid")


def build_status_line(result: Dict) -> str:
    """
    根据结果构造一行“计算状态：...”的提示。
    """
    cat = result.get("category") or "UNKNOWN"
    series_display = result.get("series_display") or ""
    calc_fields = result.get("calculated_fields") or set()
    auto_success = bool(result.get("auto_success"))

    if not auto_success:
        return "计算状态：自动化计算失败，已切换为原始价格（若存在）"

    if calc_fields:
        return f"计算状态：自动化计算成功（产品线：{cat} | 系列：{series_display}）"

    # auto_success=True 且没有任何字段需要计算 → 全部 Original
    return f"计算状态：无需自动补全，全部使用原始价格（产品线：{cat} | 系列：{series_display}）"


================================================================================
FILE: .\core\loader.py
================================================================================

import pandas as pd

from config import get_data_path, get_mapping_path


def load_france_price() -> pd.DataFrame:
    path = get_data_path("FrancePrice.xlsx")
    return pd.read_excel(path)


def load_sys_price() -> pd.DataFrame:
    path = get_data_path("SysPrice.xls")
    # xlrd 只支持 xls
    return pd.read_excel(path)


def load_france_mapping() -> pd.DataFrame:
    """
    映射文件：mapping/productline_map_france_full.csv
    """
    path = get_mapping_path("productline_map_france_full.csv")
    return pd.read_csv(path)


def load_sys_mapping() -> pd.DataFrame:
    """
    映射文件：mapping/productline_map_sys_full.csv
    """
    path = get_mapping_path("productline_map_sys_full.csv")
    return pd.read_csv(path)


================================================================================
FILE: .\core\pricing_engine.py
================================================================================

import math
from typing import Dict, Optional, Set, Tuple

import pandas as pd

from .classifier import detect_series, classify_category_and_price_group
from .pricing_rules import DDP_RULES, PRICE_RULES


PRICE_COLS = [
    "FOB C(EUR)",
    "DDP A(EUR)",
    "Suggested Reseller(EUR)",
    "Gold(EUR)",
    "Silver(EUR)",
    "Ivory(EUR)",
    "MSRP(EUR)",
]


def _to_float(v) -> Optional[float]:
    if v is None:
        return None
    try:
        if isinstance(v, str):
            v = v.strip()
            if not v:
                return None
        f = float(v)
        if math.isnan(f):
            return None
        return f
    except Exception:  # noqa: BLE001
        return None


def compute_ddp_a_from_fob(fob: Optional[float], category: str) -> Optional[float]:
    if fob is None or fob <= 0:
        return None
    rule = DDP_RULES.get(category)
    if not rule:
        return None
    ddp = fob
    for pct in rule:
        ddp *= (1 + pct)
    return ddp


def pick_price_rule(price_group: str, series_key: str) -> Optional[Dict]:
    """
    根据 price_group (大类) + series_key 在 PRICE_RULES 中选择一条规则。
    """
    cat_rule = PRICE_RULES.get(price_group)
    if not cat_rule:
        return None

    s_key_up = series_key.strip().upper()
    if s_key_up:
        # 先尝试精确匹配（不区分大小写）
        for k, v in cat_rule.items():
            if k == "_default_":
                continue
            if k.upper() == s_key_up:
                return v
        # 再尝试包含匹配
        for k, v in cat_rule.items():
            if k == "_default_":
                continue
            if k.upper() in s_key_up or s_key_up in k.upper():
                return v

    return cat_rule.get("_default_")


def compute_channel_prices(ddp_a: float, rule: Dict) -> Dict[str, Optional[float]]:
    """
    ddp_a → 各渠道价（reseller / gold / silver / ivory(installer) / msrp）
    """
    if ddp_a is None or rule is None:
        return {}

    def from_ddp(p):
        if p is None:
            return None
        return ddp_a / (1 - p)

    reseller = from_ddp(rule.get("reseller"))
    gold = from_ddp(rule.get("gold"))
    silver = from_ddp(rule.get("silver"))
    ivory = from_ddp(rule.get("ivory"))
    msrp_pct = rule.get("msrp_on_installer")

    if ivory is not None and msrp_pct is not None:
        msrp = ivory / (1 - msrp_pct)
    else:
        msrp = None

    # 有的品类 reseller 没有单独折扣，直接用 DDP A
    if reseller is None:
        reseller = ddp_a

    return {
        "DDP A(EUR)": round(ddp_a, 2),
        "Suggested Reseller(EUR)": round(reseller, 2) if reseller is not None else None,
        "Gold(EUR)": round(gold, 2) if gold is not None else None,
        "Silver(EUR)": round(silver, 2) if silver is not None else None,
        "Ivory(EUR)": round(ivory, 2) if ivory is not None else None,
        "MSRP(EUR)": round(msrp, 2) if msrp is not None else None,
    }


def _all_prices_present(fr_row: Optional[pd.Series]) -> bool:
    """
    只有 France 行存在且 7 个价格都非空时才认为“全部原始价格齐全”。
    """
    if fr_row is None:
        return False
    for col in PRICE_COLS:
        if col not in fr_row or _to_float(fr_row[col]) is None:
            return False
    return True


def _choose_sys_base_price(sales_type: str, sys_row: pd.Series) -> Optional[float]:
    """根据 Sales Type 选择 Sys 的 Min / Area Price"""
    sales_up = (sales_type or "").strip().upper()
    min_price = _to_float(sys_row.get("Min Price"))
    area_price = _to_float(sys_row.get("Area Price"))

    if sales_up in {"SMB", "DISTRIBUTION"}:
        return min_price
    if sales_up == "PROJECT":
        return area_price

    # 不识别的类型默认用 Min Price
    return min_price or area_price


def build_original_values(
    fr_row: Optional[pd.Series],
    sys_row: Optional[pd.Series],
) -> Dict[str, object]:
    """
    构造基础输出字段：
      - 优先用 France
      - 当 France 行不存在时，从 Sys 填充基础信息字段
    价格列一律从 France 拿（France 没有则先置 None，后面统一通过计算补）
    """
    data: Dict[str, object] = {}

    # Part No.
    if fr_row is not None and "Part No." in fr_row:
        data["Part No."] = fr_row.get("Part No.")
    elif sys_row is not None and "Part Num" in sys_row:
        data["Part No."] = sys_row.get("Part Num")
    else:
        data["Part No."] = None

    # Series（展示用，这里只做简单兜底；更精细的在 classifier.detect_series 里）
    if fr_row is not None:
        data["Series"] = fr_row.get("Series") or fr_row.get("系列")
    elif sys_row is not None:
        # 没有 France 时，拿 Sys 的 Second Product Line 做兜底
        data["Series"] = sys_row.get("Second Product Line") or sys_row.get("Catelog Name")
    else:
        data["Series"] = None

    # 模型 / 状态 / 描述
    if fr_row is not None:
        data["External Model"] = fr_row.get("External Model")
        data["Internal Model"] = fr_row.get("Internal Model")
        data["Sales Status"] = fr_row.get("Sales Status")
        data["Description"] = fr_row.get("Description")
    elif sys_row is not None:
        data["External Model"] = sys_row.get("External Model")
        data["Internal Model"] = sys_row.get("Internal Model")
        data["Sales Status"] = sys_row.get("Release Status")
        data["Description"] = None
    else:
        data["External Model"] = None
        data["Internal Model"] = None
        data["Sales Status"] = None
        data["Description"] = None

    # 价格列：只看 France
    if fr_row is not None:
        for col in PRICE_COLS:
            data[col] = fr_row.get(col)
    else:
        for col in PRICE_COLS:
            data[col] = None

    return data


def compute_prices_for_part(
    part_no: str,
    france_row: Optional[pd.Series],
    sys_row: Optional[pd.Series],
    france_map: pd.DataFrame,
    sys_map: pd.DataFrame,
) -> Dict:
    """
    核心：给定 PN 对应的 France 行 / Sys 行，输出：
      - final_values: 各字段最终值
      - calculated_fields: 被计算补全的字段名集合
      - category: 产品线（DDP_RULES 的 key）
      - price_group: 价格组（PRICE_RULES 顶层 key）
      - series_display: 展示用 series
      - auto_success: 是否完成了自动识别
      - used_sys: 是否用到了 Sys 做价格计算
    """
    # 1) 产品线 & 价格组
    category, price_group = classify_category_and_price_group(
        france_row, sys_row, france_map, sys_map
    )
    if not price_group:
        price_group = category

    # 2) Series（展示 + 给 PRICE_RULES 选子规则用）
    series_display, series_key = detect_series(france_row, sys_row, price_group)

    # 3) 原始值（France 优先，France 不存在则从 Sys 补基础字段）
    final_values = build_original_values(france_row, sys_row)
    calculated_fields: Set[str] = set()

    # 4) 如果 France 所有价格都齐全 → 直接视为“全部 Original”，不做计算
    if _all_prices_present(france_row):
        auto_success = category is not None and category != "UNKNOWN"
        return {
            "final_values": final_values,
            "calculated_fields": calculated_fields,
            "category": category,
            "price_group": price_group,
            "series_display": series_display,
            "auto_success": auto_success,
            "used_sys": False,
        }

    # 5) 需要做补全：先找 FOB
    fob = _to_float(final_values.get("FOB C(EUR)"))

    used_sys = False
    if (fob is None or fob <= 0) and sys_row is not None:
        # France 没给 FOB，尝试用 Sys + Sales Type 算 FOB
        sales_type = ""
        if france_row is not None and "Sales Type" in france_row:
            sales_type = str(france_row.get("Sales Type") or "")
        base_price = _choose_sys_base_price(sales_type, sys_row)
        if base_price is not None and base_price > 0:
            fob = base_price * 0.9
            final_values["FOB C(EUR)"] = round(fob, 2)
            calculated_fields.add("FOB C(EUR)")
            used_sys = True

    # 6) DDP A：如果 France 没写，就用 FOB + DDP_RULES 算
    ddp_existing = _to_float(final_values.get("DDP A(EUR)"))
    if ddp_existing is not None and ddp_existing > 0:
        ddp_a = ddp_existing
    else:
        ddp_a = compute_ddp_a_from_fob(fob, category)
        if ddp_a is not None:
            final_values["DDP A(EUR)"] = round(ddp_a, 2)
            calculated_fields.add("DDP A(EUR)")

    # 7) 渠道价：如果某列缺失且有 DDP + 价格组规则，就计算补全
    if ddp_a is not None:
        price_rule = pick_price_rule(price_group, series_key)
        if price_rule is not None:
            channel_prices = compute_channel_prices(ddp_a, price_rule)
            for col in PRICE_COLS:
                if col == "FOB C(EUR)":
                    continue  # FOB 不在 channel_prices 里
                if _to_float(final_values.get(col)) is None and col in channel_prices:
                    final_values[col] = channel_prices[col]
                    calculated_fields.add(col)

    auto_success = category is not None and category != "UNKNOWN"

    return {
        "final_values": final_values,
        "calculated_fields": calculated_fields,
        "category": category,
        "price_group": price_group,
        "series_display": series_display,
        "auto_success": auto_success,
        "used_sys": used_sys,
    }


================================================================================
FILE: .\core\pricing_rules.py
================================================================================

"""
定价规则常量：DDP_RULES & PRICE_RULES

注意：
- DDP_RULES 的 key = 产品线 category（映射表里的 category）
- PRICE_RULES 的第一层 key = price_group_hint（映射表里的 price_group_hint）
"""

# =========================
# ① DDP A 计算规则
# =========================
DDP_RULES = {
    "IPC": (0.10, 0.008, 0.02, 0.000198),
    "HAC": (0.10, 0.008, 0.02, 0.000198),
    "PTZ": (0.10, 0.008, 0.02, 0.000198),
    "THERMAL": (0.10, 0.008, 0.02, 0.000198),

    "NVR": (0.10, 0.052, 0.02, 0.000198),
    "IVSS": (0.10, 0.052, 0.02, 0.000198),
    "EVS": (0.10, 0.052, 0.02, 0.000198),
    "XVR": (0.10, 0.052, 0.02, 0.000198),

    "TRANSMISSION": (0.10, 0.0, 0.02, 0.000198),
    "IT交换机路由器": (0.10, 0.0, 0.02, 0.000198),
    "VDP": (0.10, 0.0, 0.02, 0.000198),

    "ALARM": (0.05, 0.0, 0.02, 0.000198),

    "ACCESS CONTROL": (0.10, 0.021, 0.02, 0.000198),

    "ACCESSORY": (0.10, 0.011, 0.02, 0.000198),
    "ACCESSORY线缆": (0.10, 0.037, 0.02, 0.000198),

    "监视器": (0.10, 0.0, 0.02, 0.000198),
    "IT监视器": (0.10, 0.0, 0.02, 0.000198),
    "商显/TV-WALL": (0.10, 0.14, 0.02, 0.000198),

    "键盘/解码器": (0.10, 0.034, 0.02, 0.000198),
    "交通": (0.10, 0.008, 0.02, 0.000198),
    "车载前端": (0.10, 0.008, 0.02, 0.000198),
    "车载后端": (0.10, 0.052, 0.02, 0.000198),

    "硬盘/存储介质": (0.10, 0.0, 0.02, 0.000198),

    "视频会议": (0.10, 0.034, 0.02, 0.000198),

    "电子防盗门": (0.10, 0.0, 0.02, 0.000198),
    "安检机": (0.15, 0.0, 0.02, 0.000198),
    "电子白板": (0.15, 0.034, 0.02, 0.000198),
    "烟感": (0.10, 0.02, 0.02, 0.000198),
}

# =========================
# ② 渠道价规则（基于 DDP A）
# =========================
PRICE_RULES = {
    # IPC
    "IPC": {
        "PSDW":        dict(reseller=0.12, gold=0.22, silver=0.30, ivory=0.35, msrp_on_installer=0.50),
        "针孔":         dict(reseller=0.12, gold=0.25, silver=0.30, ivory=0.35, msrp_on_installer=0.60),
        "IPC5":        dict(reseller=0.12, gold=0.27, silver=0.30, ivory=0.35, msrp_on_installer=0.60),
        "IPC5/7/MULTI-SENSOR / SPECIAL":
                       dict(reseller=0.12, gold=0.22, silver=0.30, ivory=0.35, msrp_on_installer=0.60),
        "IPC3-S2":     dict(reseller=0.12, gold=0.22, silver=0.30, ivory=0.35, msrp_on_installer=0.60),
        "IPC2-PRO":    dict(reseller=0.12, gold=0.25, silver=0.30, ivory=0.35, msrp_on_installer=0.60),
        "IPC2":        dict(reseller=0.12, gold=0.20, silver=0.30, ivory=0.35, msrp_on_installer=0.60),
        "IPC1":        dict(reseller=0.12, gold=0.20, silver=0.25, ivory=0.30, msrp_on_installer=0.60),
        "_default_":   dict(reseller=0.12, gold=0.22, silver=0.30, ivory=0.35, msrp_on_installer=0.60),
    },
    # HAC
    "HAC": {
        "_default_":   dict(reseller=0.12, gold=0.17, silver=0.20, ivory=0.25, msrp_on_installer=0.60),
    },
    # PTZ
    "PTZ": {
        "PTZ/SDT/EXPLOSION PROOF / SD10/8 / 7":
                       dict(reseller=0.12, gold=0.22, silver=0.30, ivory=0.35, msrp_on_installer=0.50),
        "SD6/5/4/3/2/1":
                       dict(reseller=0.12, gold=0.22, silver=0.30, ivory=0.35, msrp_on_installer=0.60),
        "_default_":   dict(reseller=0.12, gold=0.22, silver=0.30, ivory=0.35, msrp_on_installer=0.50),
    },
    # Thermal
    "THERMAL": {
        "TPC":         dict(reseller=0.12, gold=0.20, silver=0.25, ivory=0.30, msrp_on_installer=0.20),
        "TPC4 TPC5":   dict(reseller=0.12, gold=0.25, silver=0.30, ivory=0.35, msrp_on_installer=0.20),
        "_default_":   dict(reseller=0.12, gold=0.20, silver=0.25, ivory=0.30, msrp_on_installer=0.20),
    },
    # NVR / IVSS / EVS / XVR
    "NVR": {
        "_default_":   dict(reseller=0.12, gold=0.22, silver=0.30, ivory=0.35, msrp_on_installer=0.50),
    },
    "IVSS": {
        "_default_":   dict(reseller=0.12, gold=0.22, silver=0.30, ivory=0.35, msrp_on_installer=0.50),
    },
    "EVS": {
        "_default_":   dict(reseller=0.00, gold=0.25, silver=0.30, ivory=0.35, msrp_on_installer=0.40),
    },
    "XVR": {
        "_default_":   dict(reseller=0.12, gold=0.17, silver=0.20, ivory=0.25, msrp_on_installer=0.60),
    },
    # VDP
    "VDP": {
        "_default_":   dict(reseller=0.12, gold=0.22, silver=0.29, ivory=0.35, msrp_on_installer=0.50),
    },
    # Access Control
    "ACCESS CONTROL": {
        "_default_":   dict(reseller=0.12, gold=0.22, silver=0.35, ivory=0.40, msrp_on_installer=0.60),
    },
    # Alarm
    "ALARM": {
        "_default_":   dict(reseller=0.30, gold=0.30, silver=0.30, ivory=0.35, msrp_on_installer=0.60),
    },
    # Transmission & IT 网络
    "TRANSMISSION": {
        "_default_":   dict(reseller=0.12, gold=0.20, silver=0.23, ivory=0.25, msrp_on_installer=0.60),
    },
    "TRANSMISSION L3": {
        "_default_":   dict(reseller=0.12, gold=0.20, silver=0.23, ivory=0.25, msrp_on_installer=0.40),
    },
    "无线网桥": {
        "_default_":   dict(reseller=0.12, gold=0.16, silver=0.21, ivory=0.26, msrp_on_installer=0.40),
    },
    # Accessory
    "ACCESSORY": {
        "ACCESSORY":   dict(reseller=0.12, gold=0.22, silver=0.30, ivory=0.35, msrp_on_installer=0.60),
        "ACCESSORY 线缆":
                       dict(reseller=0.12, gold=0.22, silver=0.25, ivory=0.30, msrp_on_installer=0.60),
        "_default_":   dict(reseller=0.12, gold=0.22, silver=0.30, ivory=0.35, msrp_on_installer=0.60),
    },
    # 监视器 / 商显 / LCD
    "监视器/商显/LCD": {
        "_default_":   dict(reseller=0.12, gold=0.15, silver=0.20, ivory=0.25, msrp_on_installer=0.40),
    },
    "CCTV监视器": {
        "_default_":   dict(reseller=0.12, gold=0.20, silver=0.22, ivory=0.25, msrp_on_installer=0.40),
    },
    "IT监视器": {
        "_default_":   dict(reseller=0.12, gold=0.15, silver=0.15, ivory=0.15, msrp_on_installer=0.20),
    },
    # 键盘/解码器
    "键盘/解码器": {
        "_default_":   dict(reseller=0.15, gold=0.25, silver=0.30, ivory=0.35, msrp_on_installer=0.40),
    },
    # 交通 / 停车场
    "交通/停车场": {
        "_default_":   dict(reseller=0.15, gold=0.25, silver=0.30, ivory=0.35, msrp_on_installer=0.40),
    },
    # 车载
    "车载": {
        "_default_":   dict(reseller=0.15, gold=0.25, silver=0.30, ivory=0.35, msrp_on_installer=0.40),
    },
    # 软件
    "软件": {
        "_default_":   dict(reseller=0.15, gold=0.25, silver=0.30, ivory=0.35, msrp_on_installer=0.60),
    },
    # 硬盘/存储介质
    "硬盘/存储介质": {
        "_default_":   dict(reseller=0.10, gold=0.10, silver=0.15, ivory=0.20, msrp_on_installer=0.20),
    },
    # 电子白板
    "电子白板": {
        "_default_":   dict(reseller=0.10, gold=0.15, silver=0.15, ivory=0.15, msrp_on_installer=0.20),
    },
    # 安检
    "安检": {
        "_default_":   dict(reseller=0.15, gold=0.30, silver=0.35, ivory=0.40, msrp_on_installer=0.40),
    },
    # EAS
    "EAS": {
        "_default_":   dict(reseller=0.12, gold=0.15, silver=0.20, ivory=0.25, msrp_on_installer=0.40),
    },
    # ESL
    "ESL": {
        "_default_":   dict(reseller=0.05, gold=0.05, silver=0.10, ivory=0.15, msrp_on_installer=0.40),
    },
    # 充电桩
    "充电桩": {
        "_default_":   dict(reseller=None, gold=0.15, silver=0.15, ivory=0.15, msrp_on_installer=0.20),
    },
}


================================================================================
FILE: .\tests\__init__.py
================================================================================

# tests package — add unit tests here


